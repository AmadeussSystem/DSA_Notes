#include <vector>
#include <algorithm>

using std::vector;
using std::max;
using std::min;

// Brute Force: O(n^2)
int bruteForce(vector<int>& nums) {
    int maxSum = nums[0];

    for (int i = 0; i < nums.size(); i++) {
        int curSum = 0;
        for (int j = i; j < nums.size(); j++) {
            curSum += nums[j];
            maxSum = max(maxSum, curSum);
        }
    }
    return maxSum;
}

// Kadane's Algorithm: O(n)
int kadanes(vector<int>& nums) {
    int maxSum = nums[0];
    int curSum = 0;

    for (int n : nums) {
        curSum = max(curSum, 0);
        curSum += n;
        maxSum = max(maxSum, curSum);
    }
    return maxSum;
}

// Return the left and right index of the max subarray sum,
// assuming there's exactly one result (no ties).
// Sliding window variation of Kadane's: O(n)
vector<int> slidingWindow(vector<int> nums) {
    int maxSum = nums[0];
    int curSum = 0;
    int maxL = 0, maxR = 0;
    int L = 0;

    for (int R = 0; R < nums.size(); R++) {
        if (curSum < 0) {
            curSum = 0;
            L = R;
        }
        curSum += nums[R];
        if (curSum > maxSum) {
            maxSum = curSum;
            maxL = L; 
            maxR = R;     
        }    
    }    
    return vector<int>{maxL, maxR};
}  
// circular array with warparound ~ skip the middle and use end and first 
int maxSubarraySumCircular(vector<int>& nums) {
    int totalsum = 0;
    int curmax = 0 , maxsum = nums[0];
    int curmin = 0 , minsum = nums[0];
    for(auto num : nums){
        curmax = max(curmax+num,num);
        maxsum = max(curmax,maxsum);

        curmin = min(curmin+num,num);
        minsum = min(curmin,minsum);

        totalsum +=num;
    }

        if (maxsum < 0) return maxsum;

        return max(maxsum,totalsum-minsum);
}
// max Product using Kadanes Algorithm where the Negative Numbers can flip 
    int maxProduct(vector<int>& nums) {
        int curmaxprod = nums[0];
        int curminprod = nums[0];
        int maxprod = nums[0];

        for (int i = 1; i < nums.size(); i++) {
            int num = nums[i];
            
            int tempmax = max({num, curmaxprod * num, curminprod * num});
            int tempmin = min({num, curmaxprod * num, curminprod * num});
            
            curmaxprod = tempmax;
            curminprod = tempmin;

            maxprod = max(maxprod, curmaxprod);
        }

        return maxprod;
